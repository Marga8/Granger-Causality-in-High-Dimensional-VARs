library(readxl)
library(glmnet)
library(xts)
library(ggplot2)
library(aod)
library(dplyr)
library(igraph)
library(car)
library(highfrequency)
library(qpcR)
library(zoo)

Data_RV <- read_excel("~/Downloads/Data_RV.xlsx", 
                      col_types = c("blank", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric")) #import data
lData_RV<-as.matrix(log(Data_RV)) #take logs of every asset

ldatalag1d<-data.frame(matrix(NA, nrow = 2239, ncol = 49)) #create lag 1 daily
k=1
for(m in 1:49){
  ldatalag1d[,m]<-c(NA,lData_RV[(1:2238),k])  #define lags
  k=k+1
}
colnames(ldatalag1d)<-c(paste(colnames(lData_RV),"lag1d", sep = ""))



ldatalag1w<-data.frame(matrix(NA, nrow = 2234, ncol = 49)) #create lag 1 weekly
for(m in 1:49){
  ldatalag1w[,m]<-rollapply(lData_RV[1:2238,m], width = 5, by = 1, FUN = mean, align = "left")
}
colnames(ldatalag1w)<-c(paste(colnames(lData_RV),"lag1w", sep = ""))



ldatalag1m<-data.frame(matrix(NA, nrow = 2217, ncol = 49)) #create lag 1 monthly
for(m in 1:49){
  ldatalag1m[,m]<-rollapply(lData_RV[1:2238,m], width = 22, by = 1, FUN = mean, align = "left")
}
colnames(ldatalag1m)<-c(paste(colnames(lData_RV),"lag1m", sep = ""))

#cut off the top missings
lDatafin<-cbind(lData_RV[23:nrow(lData_RV),],ldatalag1d[23:nrow(ldatalag1d),],ldatalag1w[18:nrow(ldatalag1w),],ldatalag1m)

##########################################################################

RVassets<-lDatafin[,(1:49)] #vector of stocks 
xcont<-(lDatafin[,(50:196)]) #store the regressors (all lags)
name=c(names(RVassets))
feature=paste(names(RVassets))
dat<-matrix(0,nrow=49,ncol=49)
rownames(dat)<-names(xcont[1:49])
colnames(dat)<-feature
for (i in 1:49) {
  ycont1<-RVassets[,i] #for each asset as dep variable
  for (j in 1:49) {
    xcontnogc<-xcont[,-c(j,(j+49),(j+98))] 
    ycont2<-xcont[,j]
    ycont3<-xcont[,(j+49)]
    ycont4<-xcont[,(j+98)]
    
    lasso1=ic.glmnetboundedTWALD(xcontnogc,ycont1,crit = "bic",alpha=1,standardize=F) #lasso post double 1
    lasso2=ic.glmnetboundedTWALD(xcontnogc,ycont2,crit = "bic",alpha=1,standardize=F) #lasso post double 2
    lasso3=ic.glmnetboundedTWALD(xcontnogc,ycont3,crit = "bic",alpha=1,standardize=F) #lasso post double 3
    lasso4=ic.glmnetboundedTWALD(xcontnogc,ycont4,crit = "bic",alpha=1,standardize=F) #lasso post double 4
    
    vec1<-as.data.frame(t(lasso1$coefficients)) #store the coefficient of the ic-lasso in a vector
    vec2<-as.data.frame(t(lasso2$coefficients)) #store the coefficient of the ic-lasso in a vector
    vec3<-as.data.frame(t(lasso3$coefficients)) #store the coefficient of the ic-lasso in a vector
    vec4<-as.data.frame(t(lasso4$coefficients)) #store the coefficient of the ic-lasso in a vector
    
    tri<-bind_rows(vec1,vec2,vec3,vec4) 
    tri[is.na(tri)] <- 0
    
    if ((all(tri[1:4,2:145]==0)==TRUE)){ #if all the coeff are set to zero then run simple ols
      Yma<-ycont1
      FitMA<-lm(Yma~ycont2+ycont3+ycont4)
      FitMA1<-summary(FitMA)[4]
      FitMA2<-unlist(FitMA1)
      FitMA3<-FitMA2[-c(1:5)]
      result2<-FitMA3
    } else if ((all(tri[1:4,2:145]==0)==F)){
      tri<-as.data.frame(tri[,colSums(tri !=0)>0]) #eliminate those columns where BOTH are zero
      xcont<-as.data.frame(xcont)  #transform into dataframe to use dplyr
      newX<-as.data.frame(lapply(intersect(names(xcont),names(tri)),function(name) xcont[name])) #keep the matching columns
      newX<-as.matrix(newX)
      newXX<-cbind(ycont2,ycont3,ycont4,newX)
      newXX<-as.matrix(newXX)
      Model<-lm(ycont1~newXX)
      ######## manual #######
      #gigi<-coef(Model)[2]
      #minni<-vcov(Model)[2,2]
      #result<-(gigi^2)/minni
      ######################
      #result<-linearHypothesis(Model, c("newXX"), 
      #                c(0), test = "Chisq")
      
      #INSERT HERE A GET-AWAY for VCOV=NULL in case want to use normal lower bound instead of lower bound -1
      Wald<-linearHypothesis(Model, c("newXXycont2","newXXycont3","newXXycont4"),
                             c(0,0,0), test = "F",white.adjust ="hc3" )
      #result<-wald.test(vcov(Model),coef(Model),Terms = c(2),H0=c(0))
      #result1<-result[6]
      #result2<-unlist(result1)
      pippocippo<-Wald$`Pr(>F)`[2]
      pippo<-vcov(Model)
      
    }
    
    output<-pippocippo
    
    if(output>0.01){
      print(paste(names(xcont[j]),"does NOT GC",names(RVassets[i])))
    }
    
    if(output<=0.01){ #reject/not reject (F test for small samples)
      print(paste(names(xcont[j]),"does GC",names(RVassets[i])))
      dat[which(rownames(dat)==names(xcont[j])),which(colnames(dat)==names(RVassets[i]))]<-1
    }
  }
}
rownames(dat)<-colnames(dat)
dat<-as.matrix(dat)
colnames(dat)<-c()


### FIRST OPTION ###

network=graph_from_adjacency_matrix(dat, mode='directed',diag=F,add.rownames = TRUE )
V(network)$label = rownames(dat)

network2<-get.edgelist(network, names=TRUE) # makes it into an edge list 
network3<-graph_from_edgelist(network2) #create graph

V(network3)$label=rownames(dat)

#E(network3)[c(1,2,3)]$color="red" #color apple connections in RED


plot(network3,directed=T, layout=layout.circle, main="Realized Volatility Contagion",
     edge.arrow.size=.1, vertex.color=c("gold"), vertex.size=5, vertex.frame.color="gray", 
     vertex.label.color="black",vertex.label.cex=0.5, vertex.label.dist=0.5, edge.curved=0)#,edge.width=c(rep(1,3),rep(2,161))) 

### SECOND OPTION ###
plot(network3, vertex.size=10,edge.arrow.size=.15,vertex.label.cex=0.5,vertex.label.dist=0)#,edge.width=c(rep(3,3),rep(1,161))) 

#### CLUSTERS #####
# Community detection based on edge betweenness (Newman-Girvan)
# High-betweenness edges are removed sequentially (recalculating at each step) 
# and the best partitioning of the network is selected.

## make graph undirected ##
net.sym <- as.undirected(network3, mode= "collapse")

ceb <- cluster_edge_betweenness(net.sym,directed=T) 

dendPlot(ceb, mode="hclust")

plot(ceb, net.sym,vertex.size=10, 
     vertex.label.color="black",vertex.label.cex=0.51, vertex.label.dist=1, edge.curved=0) 



###############################################################################################################
######################## to Plot PG and MS ###########################
V(network3)$label=c("AAPL","ABT","AXP","BA","BAC","BMY","BP","C","CAT","CL","CSCO","CVX","DELL","DIS","EK"
                    ,"EXC","F","FDX","GE","GM","HD","HNZ","HON","IBM","INTC","JNJ","KO","LLY","MCD","MMM","MOT",
                    "MRK","MS","MSFT","ORCL","PEP","PFE","PG","QCOM","SLB","T","TWX","UN","VZ","WFC","WMT","WYE",
                    "XOM","XRX")


E(network3)[c(110:121)]$color="red" #color PG connections in RED
E(network3)[c(1:83)]$color="gray"
E(network3)[c(84:89)]$color="blue"
E(network3)[c(90:109)]$color="gray"
E(network3)[c(122:164)]$color="gray"


plot(network3,directed=T, layout=layout.circle, main="",
     edge.arrow.size=.1, vertex.color=c("gold"), vertex.size=5, vertex.frame.color="gray", 
     vertex.label.color="black",vertex.label.cex=0.51, vertex.label.dist=-0.5, edge.curved=0,edge.width=c(rep(1,83),rep(2,6),rep(1,20),rep(2,12),rep(1,43))) #OK



#################################   DISREGARD FROM HERE ONWARDS ########################################
#################################################################################################################
#################################################
### THIRD OPTION PROBLEMATIC FOR NOW ###
devtools::install_github("garthtarr/edgebundleR")
install.packages("edgebundleR")
library(edgebundleR)

edgebundle(network, fontsize = 10) #da aggiustare
##################################################





######################################################################
#trials
adjm <- matrix(sample(0:1, 100, replace=TRUE, prob=c(0.9,0.1)), nc=10)
g1 <- graph_from_adjacency_matrix( adjm )
plot(g1,layout=layout.circle)

edgebundle(g1)


ws_graph <- watts.strogatz.game(1, 50, 4, 0.05)
edgebundle(ws_graph,tension = 0.1,fontsize = 18,padding=40)

