library(readxl)
library(glmnet)
library(xts)
library(ggplot2)
library(aod)
library(dplyr)
library(igraph)
library(car)
library(highfrequency)
library(qpcR)
library(zoo)

Data_RV <- read_excel("~/Downloads/Data_RV.xlsx", 
                      col_types = c("blank", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric", "numeric", 
                                    "numeric", "numeric")) #import data
lData_RV<-as.matrix(log(Data_RV)) #take logs of every asset

ldatalag1d<-data.frame(matrix(NA, nrow = 2239, ncol = 49)) #create lag 1 daily
k=1
for(m in 1:49){
  ldatalag1d[,m]<-c(NA,lData_RV[(1:2238),k])  #define lags
  k=k+1
}
colnames(ldatalag1d)<-c(paste(colnames(lData_RV),"lag1d", sep = ""))



ldatalag1w<-data.frame(matrix(NA, nrow = 2234, ncol = 49)) #create lag 1 weekly
for(m in 1:49){
  ldatalag1w[,m]<-rollapply(lData_RV[1:2238,m], width = 5, by = 1, FUN = mean, align = "left")
}
colnames(ldatalag1w)<-c(paste(colnames(lData_RV),"lag1w", sep = ""))



ldatalag1m<-data.frame(matrix(NA, nrow = 2217, ncol = 49)) #create lag 1 monthly
for(m in 1:49){
  ldatalag1m[,m]<-rollapply(lData_RV[1:2238,m], width = 22, by = 1, FUN = mean, align = "left")
}
colnames(ldatalag1m)<-c(paste(colnames(lData_RV),"lag1m", sep = ""))

#cut off the top missings
lDatafin<-cbind(lData_RV[23:nrow(lData_RV),],ldatalag1d[23:nrow(ldatalag1d),],ldatalag1w[18:nrow(ldatalag1w),],ldatalag1m)

##########################################################################

RVassets<-lDatafin[,(1:49)] #vector of stocks 
xcont<-(lDatafin[,(50:196)]) #store the regressors (all lags)
name=c(names(RVassets))
feature=paste(names(RVassets))
dat<-matrix(0,nrow=49,ncol=49)
rownames(dat)<-names(xcont[1:49])
colnames(dat)<-feature
for (i in 1:49) {
  ycont1<-RVassets[,i] #for each asset as dep variable
  for (j in 1:49) {
    xcontnogc<-xcont[,-c(j,(j+49),(j+98))] 
    ycont2<-xcont[,j]
    ycont3<-xcont[,(j+49)]
    ycont4<-xcont[,(j+98)]
    
    lasso1=ic.glmnetboundedT(xcontnogc,ycont1,crit = "bic",alpha=1,standardize=F) #lasso post double 1
    lasso2=ic.glmnetboundedT(xcontnogc,ycont2,crit = "bic",alpha=1,standardize=F) #lasso post double 2
    lasso3=ic.glmnetboundedT(xcontnogc,ycont3,crit = "bic",alpha=1,standardize=F) #lasso post double 3
    lasso4=ic.glmnetboundedT(xcontnogc,ycont4,crit = "bic",alpha=1,standardize=F) #lasso post double 4
    
    vec1<-as.data.frame(t(lasso1$coefficients)) #store the coefficient of the ic-lasso in a vector
    vec2<-as.data.frame(t(lasso2$coefficients)) #store the coefficient of the ic-lasso in a vector
    vec3<-as.data.frame(t(lasso3$coefficients)) #store the coefficient of the ic-lasso in a vector
    vec4<-as.data.frame(t(lasso4$coefficients)) #store the coefficient of the ic-lasso in a vector
    
    tri<-bind_rows(vec1,vec2,vec3,vec4) 
    tri[is.na(tri)] <- 0
    
    if ((all(tri[1:4,2:145]==0)==TRUE)){ #if all the coeff are set to zero then run simple ols
      Yma<-ycont1
      FitMA<-lm(Yma~ycont2+ycont3+ycont4)
    } else if ((all(tri[1:4,2:145]==0)==F)){
      tri<-as.data.frame(tri[,colSums(tri !=0)>0]) #eliminate those columns where BOTH are zero
      xcont<-as.data.frame(xcont)  #transform into dataframe to use dplyr
      newX<-as.data.frame(lapply(intersect(names(xcont),names(tri)),function(name) xcont[name])) #keep the matching columns
      newX<-as.matrix(newX)
      newXX<-cbind(ycont2,ycont3,ycont4,newX)
      newXX<-as.matrix(newXX)
      FitMR<-lm(ycont1~newX) #OLS regression to get residuals for the auxiliary model
      Yma<-matrix(FitMR$residuals) #residuals for the MA
      
      #### HETEROSCEDASTIC ROBUST ####
      step2<-lm(ycont2~newX) #each of the excluded regressors is regressed on the included ones and residuals are taken
      step2<-(step2$residuals)
      step22<-lm(ycont3~newX)
      step22<-(step22$residuals)
      step222<-lm(ycont4~newX)
      step222<-(step222$residuals)
      
      
      prod1<-Yma*(step2)
      prod2<-Yma*(step22)
      prod3<-Yma*(step222)
      
      
      
      depv<-c(rep(1,2217))
      regre<-lm(formula=depv~ prod1+ prod2+ prod3 -1) #SHOULD BE WITHOUT CONST
      
      
      rss<-RSS(regre) #calculate RSS
      
    }
    
    output<-(2217-rss)
    
    if(output<=qchisq(.99,df=3)){
     pval1<-pchisq(output,df=3,lower.tail = F)
     print(paste(names(xcont[j]),"does NOT GC",names(RVassets[i])))
    }
    
    if(output>qchisq(.99,df=3)){ #reject/not reject (F test for small samples)
      pval1<-pchisq(output,df=3,lower.tail = F)
      #print(pval1)
      print(paste(names(xcont[j]),"does GC",names(RVassets[i])))
      dat[which(rownames(dat)==names(xcont[j])),which(colnames(dat)==names(RVassets[i]))]<-1
    }
  }
}
rownames(dat)<-colnames(dat)
dat<-as.matrix(dat)
colnames(dat)<-c()


### FIRST OPTION ###

network=graph_from_adjacency_matrix(dat, mode='directed',diag=F,add.rownames = TRUE )
V(network)$label = rownames(dat)

network2<-get.edgelist(network, names=TRUE) # makes it into an edge list 
network3<-graph_from_edgelist(network2) #create graph

V(network3)$label=rownames(dat)

#E(network3)[c(1,2,3)]$color="red" #color apple connections in RED


plot(network3,directed=T, layout=layout.circle, main="Realized Volatility Contagion",
     edge.arrow.size=.1, vertex.color=c("gold"), vertex.size=5, vertex.frame.color="gray", 
     vertex.label.color="black",vertex.label.cex=0.5, vertex.label.dist=0.5, edge.curved=0)#,edge.width=c(rep(1,3),rep(2,161))) 

### SECOND OPTION ###
plot(network3, vertex.size=10,edge.arrow.size=.15,vertex.label.cex=0.5,vertex.label.dist=0)#,edge.width=c(rep(3,3),rep(1,161))) 

#### CLUSTERS #####
# Community detection based on edge betweenness (Newman-Girvan)
# High-betweenness edges are removed sequentially (recalculating at each step) 
# and the best partitioning of the network is selected.

## make graph undirected ##
net.sym <- as.undirected(network3, mode= "collapse")

ceb <- cluster_edge_betweenness(net.sym,directed=T) 

dendPlot(ceb, mode="hclust")

plot(ceb, net.sym,vertex.size=10, 
     vertex.label.color="black",vertex.label.cex=0.51, vertex.label.dist=1, edge.curved=0) 



###############################################################################################################
######################## to Plot PG and MS ###########################
V(network3)$label=c("AAPL","ABT","AXP","BA","BAC","BMY","BP","C","CAT","CL","CSCO","CVX","DELL","DIS","EK"
                    ,"EXC","F","FDX","GE","GM","HD","HNZ","HON","IBM","INTC","JNJ","KO","LLY","MCD","MMM","MOT",
                    "MRK","MS","MSFT","ORCL","PEP","PFE","PG","QCOM","SLB","T","TWX","UN","VZ","WFC","WMT","WYE",
                    "XOM","XRX")


E(network3)[c(110:121)]$color="red" #color PG connections in RED
E(network3)[c(1:83)]$color="gray"
E(network3)[c(84:89)]$color="blue"
E(network3)[c(90:109)]$color="gray"
E(network3)[c(122:164)]$color="gray"


plot(network3,directed=T, layout=layout.circle, main="",
     edge.arrow.size=.1, vertex.color=c("gold"), vertex.size=5, vertex.frame.color="gray", 
     vertex.label.color="black",vertex.label.cex=0.51, vertex.label.dist=-0.5, edge.curved=0,edge.width=c(rep(1,83),rep(2,6),rep(1,20),rep(2,12),rep(1,43))) #OK

